# grep2awk: 
# A zle convenience function to exchange a `grep` on the command line
# into a corresponding `awk`-line. 
# How to use: 
# Drop this file somewhere in your $fpath. And configure your shell to
# make use of it:
#
#    autoload grep2awk
#    zle -N grep2awk
#    bindkey "^X^A" grep2awk
#
# This makes the widget available under <CTRL-X><CTRL-A>. 
#
# Known bugs:
# - The command conversions have not been thorougly tested
#
# The files t/comptest and t/ztst.zsh are taken (and modified) from the
# zsh project. This project can be used under the same terms as the zsh 
# project. 
#
# By Joep van Delft, 2015


emulate -L zsh
setopt extendedglob
autoload -Uz split-shell-arguments

regex2awkprog() {
    local re prelude action prog

    re=${(Q)1} # Remove one level of quoting, so we have what
               # grep would receive

    (( opt[F] > 0 )) && {
        re="$(fixed2ere $re)"
    }

    # A sanity check:
    (( opt[E] + opt[F] + opt[G] + opt[P] > 1 )) && {
        zle -M "Options E, F, G and P are mutually exclusive. Exiting."
        return 1
    }
    (( opt[G] == 1 || opt[E] + opt[F] + opt[P] == 0 )) && {
        # It is Basic Regular Expression
        re="$(bre2ere $re)"
    }

    (( opt[w] > 0 )) && {
        re="\\<($re)\\>" 
    }
    (( opt[x] > 0 )) && {
        re="^($re)$"
    }
    # Wrap in slashes, and replace any single quote with its
    # ASCII code: 
    re=/${re//\'/\\47}/

    # Negate the pattern if told so: 
    (( opt[v] > 0 )) && {
        re="!$re"
    }

    (( opt[i] + opt[y] > 0 )) && {
        prelude+="BEGIN{IGNORECASE=1}; "
    }
    # The print action. Add some extra stuff if line count or file name
    # are enabled.
    action="{print ${opt[H]:+FILENAME\":\"}${opt[n]:+NR\":\"}\$0}"

    # c, H, l and L are mutually exclusive. One of them will win. 
    (( opt[H] + opt[l] + opt[L] + opt[c] > 1 )) && {
        zle -M "grep2awk:Options c, H, l and L are mutually exclusive."
        zle -M "Exiting."
        return 1
    }

    (( opt[c] > 0 )) && {
        # This is incompatible with `grep -c`, as files where the count == 0
        # are not displayed.  This is saner behavior, IMHO. 
        prelude+='BEGINFILE{c=0};ENDFILE{if(c>0)print FILENAME":"c}; '
        action='{c++}'
    }
    (( opt[l] > 0 )) && {
        action="{print FILENAME; nextfile}"
    }
    (( opt[L] > 0 )) && {
        prelude+="BEGINFILE{flag=0};ENDFILE{if (flag==0)print FILENAME}; "
        action="{flag=1; nextfile}"
    }
    prog="${prelude}${re} $action"
    printf ${(qq)prog}
}

fixed2ere() {
    local p specialchars ere
    # We already receive a backslash escaped version of the
    # string by virtue of the ``(q)``-flag when this function is called.
    # That means that we need to transform the characters in the
    # first line to the corresponding character sequences in the
    # second line: 
    #
    #     +  |  {  }  [  ]  (  )  *  .  ?  \  $  ^
    #    \+ \| \{ \} \[ \] \( \) \* \. \? \\ \$ \^

    specialchars='\+|\||\{|\}|\[|\]|\(|\)|\*|\.|\?|\$|\^'
    str=$1
    ere=""
    for i in {1..$#str}; do
        print $i: \<$str[$i]\> >>log
        if [[ $str[$i] =~ $specialchars ]]; then
            ere+="\\\\$str[$i]"
        elif [[ $str[$i] == $'\n' ]]; then
            # This works after arrowing up into history, but not 
            # directly after writing it. Is there a way to detect
            # if this is the case? 
            ere+='|'
        elif [[ $str[$i] == '\' ]]; then
            ere+="\\\\\\\\$str[$i]"
        else
            ere+="$str[$i]"
        fi
    done

    printf $ere
}

bre2ere() {
    # Basic Regular Expression to Extended Regular Expression
    #
    # What needs to be done:
    # Translate BRE: \+,\{,\},\|,\(,\), +, {, }, |, (, )
    #        to ERE:  +, {, }, |, (, ),\+,\{,\},\|,\(,\)
    #
    # But only if the backslash is not escaped with a backslash. 

    local bre ere i re
    bre=$1
    ere=""
    esc=off
    specialchars="\+|\||\{|\}|\(|\)"
    for i in {1..$#bre}; do
        if [[ ${bre[$i]} =~ $specialchars ]]; then
            if [[ $esc == on ]]; then
                ere+="$bre[$i]" # The escape sign is dropped now
                esc=off
            else
                ere+="\\\\$bre[$i]"
            fi
        elif [[ $bre[$i] == "\\" ]]; then
            if [[ $esc == on ]]; then
                ere+="\\\\\\\\"
                esc=off
            else
                esc=on
            fi
        else
            ere+="$bre[$i]"
            esc=off
        fi
    done
    print $ere
}

swap_command() {
    flag=1
    reply[$i]="awk"
    (( cursor += $#reply[$i] ))
}

main() {
    # Needs to be in its own scope, to not have the variables leak to
    # the main shell process. 
    local replacement_line REPLY REPLY2 flag cursor grepopts
    local -a reply
    typeset -A opt

    # Store line as $reply[@]:
    split-shell-arguments

    flag=0
    cursor=0
    for (( i=1; i<=$#reply; i++ )); do 
        if (( i%2==1 && flag < 2 )); then
            # Uneven "words" are whitespace. Only interested in changing the
            # cursor position if exchanging the regex is not replaced by the awk
            # program yet (flag < 2). 
            len=$#reply[$i]
            (( cursor += len ))
        elif [[ $flag = 0 ]]; then
            case $reply[$i] in
                (grep)
                    swap_command
                    ;;
                (egrep)
                    swap_command
                    typeset "opt[E]"=1
                    ;;
                (fgrep)
                    swap_command
                    typeset "opt[F]"=1
                    ;;
            esac
        elif [[ $flag = 1 && $reply[$i] = -* ]]; then
            # It an option to grep? A regular expression of
            # the options that are recognized: 
            grepopts="c|E|F|G|H|i|l|L|n|v|w|x|y"
            for ((l=1; l<$#reply[$i]; l++)); do
                #check those options!
                o=${reply[$i]:$l:1}
                if [[ $o =~ $grepopts ]]; then
                    typeset "opt[$o]"=1
                elif [[ $o == "-" ]]; then
                    zle -M "grep2awk: Long options to grep are not supported"
                    return 1
                else
                    zle -M "grep2awk: Option $o is not supported"
                    return 1
                fi
            done

            # For now: Delete the options, and the now superfluous whitespace:
            reply[$i]=""
            reply[$i+1]=""
            # And leave the cursor pointer where it was. 

        elif [[ $flag = 1 ]]; then
            # This is the regex. Replace with the awk program. 
            
            reply[$i]=$(regex2awkprog $reply[$i])
            (( cursor += $#reply[$i] - 2 ))
            flag=2
        fi
        # Append the current version of $reply[$i] to replacement_line: 
        replacement_line+=$reply[$i]
    done

    # Now we are done. Apply the changes to the BUFFER:
    BUFFER="$replacement_line"
    CURSOR=cursor
}

main


# vim: ft=zsh
