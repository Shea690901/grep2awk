# grep2awk: 
# A zle convenience function to exchange a `grep` on the command line
# into a corresponding `awk`-line. 
# How to use: 
# Drop this file somewhere in your $fpath. And configure your shell to
# make use of it:
#
#    autoload grep2awk
#    zle -N grep2awk
#    bindkey "^X^A" grep2awk
#
# This makes the widget available under <CTRL-X><CTRL-A>. 
#
# Known bugs:
# - The command conversions have not been thorougly tested
# - From Fixed to ERE, there are issues with backslashes
#
# The files t/comptest and t/ztst.zsh are taken (and modified) from the
# zsh project. This project can be used under the same terms as the zsh 
# project. 
#
# By Joep van Delft, 2015


emulate -L zsh
setopt extendedglob
autoload -Uz split-shell-arguments

regex2awkprog() {
    local re prelude action prog

    re=${(Q)1}

    (( opt[F] > 0 )) && {
        re="$(fixed2ere ${(q)re})"
    }

    (( opt[F] + opt[E] + opt[P] == 0 )) && {
        # It is Basic Regular Expression
        re="$(bre2ere ${(q)re})"
    }

    (( opt[w] > 0 )) && {
        re="\\<($re)\\>" 
    }
    (( opt[x] > 0 )) && {
        re="^($re)$"
    }
    re=/$re/
    (( opt[v] > 0 )) && {
        re="!$re"
    }
    # TODO: Replace single quotes in the regex with \47.
    (( opt[i] > 0 )) && {
        prelude+="BEGIN{IGNORECASE=1}; "
    }
    # The print action. Add some extra stuff if line count or file name
    # are enabled.
    action="{print ${opt[H]:+FILENAME\":\"}${opt[n]:+NR\":\"}\$0}"
    # c, H, l and L are mutually exclusive. One of them will win. 
    # TODO: Maybe should fail here explicitly:
    #
    #    (( opt[H] + opt[l] + opt[L] > 1 opt[c] )) && exit 1

    (( opt[c] > 0 )) && {
        # This is incompatible with `grep -c`, as files where the count == 0
        # are not displayed.  This is saner behavior, IMHO. 
        prelude+='BEGINFILE{c=0};ENDFILE{if(c>0)print FILENAME":"c}; '
        action='{c++}'
    }
    (( opt[l] > 0 )) && {
        action="{print FILENAME; nextfile}"
    }
    (( opt[L] > 0 )) && {
        prelude+="BEGINFILE{flag=0};ENDFILE{if (flag==0)print FILENAME}; "
        action="{flag=1; nextfile}"
    }
    prog="${prelude}${re} $action"
    printf ${(qq)prog}
}

fixed2ere() {
    local p
    # Changing the special characters from a fixed string regex into
    # a properly escaped Extended Regular Expression. Did not yet manage to 
    # properly escape two consequtive backslash characters.
    p=${${1}//\\/\\\\\\\\}
    printf $p
}

bre2ere() {
    # Basic Regular Expression to Extended Regular Expression
    #
    # What needs to be done:
    # Replace \+, \{, \[, \|, \(, \) with 
    #          +,  {,  [,  |,  (,  ) respectively. 
    # And:     +,  {,  [,  |,  (,  ) with
    #         \+, \{, \[, \|, \(, \). 
    # But only if the backslash is not escaped with a backslash. 
    local bre ere i re
    bre=${(Q)1}
    ere=""
    esc=off
    specialchars="\+|\||\{|\[|\(|\)"
    for i in {1..$#bre}; do
        if [[ ${bre[$i]} =~ $specialchars ]]; then
            if [[ $esc == on ]]; then
                ere="${ere}${bre[$i]}"
                esc=off
            else
                ere="${ere}\\\\${bre[$i]}"
            fi
        elif [[ $bre[$i] == "\\" ]]; then
            if [[ $esc == on ]]; then
                ere="${ere}\\\\\\\\"
                esc=off
            else
                esc=on
            fi
        else
            ere="${ere}${bre[$i]}"
            esc=off
        fi
    done
    print $ere
}

swap_command() {
    flag=1
    reply[$i]="awk"
    (( cursor += $#reply[$i] ))
}

main() {
    # Needs to be in its own scope, to not have the variables leak to
    # the main shell process. 
    local replacement_line REPLY REPLY2 flag cursor
    local -a reply
    typeset -A opt

    # Store line in $reply[@]:
    split-shell-arguments

    flag=0
    cursor=0
    for (( i=1; i<=$#reply; i++ )); do 
        if (( i%2==1 && flag < 2 )); then
            # Uneven "words" are whitespace. Only interested in changing the
            # cursor position if exchanging the regex is not replaced by the awk
            # program yet (flag < 2). 
            len=$#reply[$i]
            (( cursor += len ))
        elif [[ $flag = 0 ]]; then
            case $reply[$i] in
                (grep)
                    swap_command
                    ;;
                (egrep)
                    swap_command
                    typeset "opt[E]"=1
                    ;;
                (fgrep)
                    swap_command
                    typeset "opt[F]"=1
                    ;;
            esac
        elif [[ $flag = 1 && $reply[$i] = -* ]]; then
            # It an option to grep? 
            # If so, deal with the option. 
            for ((l=1; l<$#reply[$i]; l++)); do
                #check those options!
                case ${reply[$i]:$l:1} in
                    (v) typeset "opt[v]"=1
                        ;;
                    (w) typeset "opt[w]"=1
                        ;;
                    (l) typeset "opt[l]"=1
                        ;;
                    (L) typeset "opt[L]"=1
                        ;;
                    (x) typeset "opt[x]"=1
                        ;;
                    (H) typeset "opt[H]"=1
                        ;;
                    (c) typeset "opt[c]"=1
                        ;;
                    (E) typeset "opt[E]"=1
                        ;;
                    (P) zle -M "grep2awk: PCRE grep is not supported"
                        return 1
                        ;;
                    (F) typeset "opt[F]"=1
                        ;;
                    (i) typeset "opt[i]"=1
                        ;;
                    (n) typeset "opt[n]"=1
                        ;;
                    (A|B|C)
                        zle -M "grep2awk: Context switches (A,B,C) are as of yet not supported"
                        return 1
                        ;;
                    (*) continue
                        ;;
                esac
            done

            # For now: Delete the options, and the now superfluous whitespace:
            reply[$i]=""
            reply[$i+1]=""
            # And leave the cursor pointer where it was. 

        elif [[ $flag = 1 ]]; then
            # This is the regex. Replace with the awk program. 
            
            reply[$i]=$(regex2awkprog $reply[$i])
            (( cursor += $#reply[$i] - 2 ))
            flag=2
        fi
        # Append the current version of $reply[$i] to replacement_line: 
        replacement_line+=$reply[$i]
    done

    # Now we are done. Apply the changes to the BUFFER:
    BUFFER="$replacement_line"
    CURSOR=cursor
}

main


# vim: ft=zsh
