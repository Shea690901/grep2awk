emulate -L zsh
setopt extendedglob
autoload -Uz split-shell-arguments

change_regex() {
    re=${(Q)1}
    (( opt[w] > 0 )) && {
        re="\\<($re)\\>" 
    }
    (( opt[x] > 0 )) && {
        re="^($re)$"
    }
    re="/$re/"
    (( opt[v] > 0 )) && {
        re="!$re"
    }
    action="{print}"
    # c, H, l and L are mutually exclusive. One of the will win. 
    # TODO: Maybe should fail here explicitly:
    #
    #    (( opt[H] + opt[l] + opt[L] > 1 opt[c] )) && exit 1

    (( opt[c] > 0 )) && {
        prelude='BEGINFILE{c=0};ENDFILE{if(c>0)print FILENAME":"c} '
        action='{c++}'
    }
    (( opt[H] > 0 )) && {
        action='{print FILENAME":"$0}'
    }
    (( opt[l] > 0 )) && {
        action="{print FILENAME; nextfile}"
    }
    (( opt[L] > 0 )) && {
        prelude="BEGINFILE{flag=0};ENDFILE{if (flag==0)print FILENAME}; "
        action="{flag=1; nextfile}"
    }
    prog="${prelude}${re} $action"
    printf ${(qq)prog}
}

main() {
    # Needs to be in its own scope, to not have the variables leak to
    # the main shell process. 
    local replacement_line REPLY REPLY2 flag cursor
    local -a reply
    typeset -A opt

    # Store line in $reply[@]:
    split-shell-arguments

    flag=0
    cursor=0
    for (( i=1; i<=$#reply; i++ )); do 
        if (( i%2==1 && flag < 2 )); then
            # Uneven "words" are whitespace. Only interested in changing the
            # cursor position if exchanging the regex is not replaced by the awk
            # program yet (flag < 2). 
            len=$#reply[$i]
            (( cursor += len ))
        elif [[ $flag = 0 ]]; then
            case $reply[$i] in
                (grep)
                    flag=1
                    (( cursor += 3 ))
                    reply[$i]="awk"
                    ;;
                (egrep)
                    flag=1
                    (( cursor += 3 ))
                    reply[$i]="awk"
                    opt[extended]++
                    ;;
                (pgrep)
                    flag=1
                    (( cursor += 3 ))
                    reply[$i]="awk"
                    opt[pcre]++
                    ;;
            esac
        elif [[ $flag = 1 && $reply[$i] = -* ]]; then
            # It an option to grep? 
            # If so, deal with the option. 
            for ((l=1; l<$#reply[$i]; l++)); do
                #check those options!
                case ${reply[$i]:$l:1} in
                    (v) typeset "opt[v]"=1
                        ;;
                    (w) typeset "opt[w]"=1
                        ;;
                    (l) typeset "opt[l]"=1
                        ;;
                    (L) typeset "opt[L]"=1
                        ;;
                    (x) typeset "opt[x]"=1
                        ;;
                    (H) typeset "opt[H]"=1
                        ;;
                    (c) typeset "opt[c]"=1
                        ;;
                    (*) continue
                        ;;
                esac
            done

            # For now: Delete the options, and the now superfluous whitespace:
            reply[$i]=""
            reply[$i+1]=""
            # And leave the cursor pointer where it was. 

        elif [[ $flag = 1 ]]; then
            # This is the regex. Replace with the awk program. 
            
            reply[$i]=$(change_regex $reply[$i])
            (( cursor += $#reply[$i] - 2 ))
            flag=2
        fi
        # Append the current version of $reply[$i] to replacement_line: 
        replacement_line+=$reply[$i]
    done

    # Now we are done. Apply the changes to the BUFFER:
    BUFFER="$replacement_line"
    CURSOR=cursor
}
main
