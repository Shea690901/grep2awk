# grep2awk:
# A zle convenience function to exchange a `grep` on the command line
# into a corresponding `awk`-line.
# How to use:
# Drop this file somewhere in your $fpath. And configure your shell to
# make use of it:
#
#    autoload grep2awk
#    zle -N grep2awk
#    bindkey "^X^A" grep2awk
#
# This makes the widget available under <CTRL-X><CTRL-A>.
#
# Known bugs:
# - The command conversions have not been thorougly tested
#
# The files t/comptest and t/ztst.zsh are taken (and modified) from the
# zsh project. This project can be used under the same terms as the zsh
# project.
#
# By Joep van Delft, 2015


emulate -L zsh
setopt extendedglob
autoload -Uz split-shell-arguments

main() {
    # Needs to be in its own scope, to not have the variables leak to
    # the main shell process.
    local replacement_line REPLY REPLY2 flag cursor grepopts
    local -a reply
    typeset -A opt

    # Define some functions first:
    #   regex2awkprog
    #   fixed2ere
    #   bre2ere
    #   swapcommand

    regex2awkprog() {
        local re prelude action prog

        re=${(Q)1} # Remove one level of quoting, so we have what
                   # grep would receive.

        (( opt[F] > 0 )) && {
            re="$(fixed2ere $re)"
        }

        # A sanity check:
        (( opt[E] + opt[F] + opt[G] + opt[P] > 1 )) && {
            zle -M "grep2awk:Options E, F, G and P are mutually exclusive."
            zle -M "Exiting."
            return 1
        }
        (( opt[G] == 1 || opt[E] + opt[F] + opt[P] == 0 )) && {
            # It is Basic Regular Expression
            re="$(bre2ere $re)"
        }

        (( opt[w] > 0 )) && {
            re="\\<($re)\\>"
        }
        (( opt[x] > 0 )) && {
            re="^($re)$"
        }
        # Wrap in slashes, and replace any single quote with its
        # ASCII code:
        re=/${re//\'/\\47}/

        # Negate the pattern if told so:
        (( opt[v] > 0 )) && {
            re="!$re"
        }

        (( opt[i] + opt[y] > 0 )) && {
            prelude+="BEGIN{IGNORECASE=1}; "
        }
        # The print action. Add some extra stuff if line count or file name
        # are enabled.
        action="{print ${opt[H]:+FILENAME\":\"}${opt[n]:+NR\":\"}\$0}"

        # c, H, l and L are mutually exclusive. One of them will win.
        (( opt[H] + opt[l] + opt[L] + opt[c] > 1 )) && {
            zle -M "grep2awk:Options c, H, l and L are mutually exclusive."
            zle -M "Exiting."
            return 1
        }

        (( opt[c] > 0 )) && {
            # This is incompatible with `grep -c`, as files where the count == 0
            # are not displayed.  This is saner behavior, IMHO.
            prelude+='BEGINFILE{c=0};ENDFILE{if(c>0)print FILENAME":"c}; '
            action='{c++}'
        }
        (( opt[l] > 0 )) && {
            action="{print FILENAME; nextfile}"
        }
        (( opt[L] > 0 )) && {
            prelude+="BEGINFILE{flag=0};ENDFILE{if (flag==0)print FILENAME}; "
            action="{flag=1; nextfile}"
        }
        prog="${prelude}${re} $action"
        printf -- ${(qq)prog}
    }

    fixed2ere() {
        local p specialchars ere
        # We already receive a backslash escaped version of the
        # string by virtue of the ``(q)``-flag when this function is called.
        # That means that we need to transform the characters in the
        # first line to the corresponding character sequences in the
        # second line:
        #
        #     +  |  {  }  [  ]  (  )  *  .  ?  \  $  ^
        #    \+ \| \{ \} \[ \] \( \) \* \. \? \\ \$ \^

        specialchars='\+|\||\{|\}|\[|\]|\(|\)|\*|\.|\?|\$|\^'
        str=$1
        ere=""
        for i in {1..$#str}; do
            if [[ $str[$i] =~ $specialchars ]]; then
                ere+="\\$str[$i]"
            elif [[ $str[$i] == $'\n' ]]; then
                # This works after arrowing up into history, but not
                # directly after writing it. Is there a way to detect
                # if this is the case?
                ere+='|'
            elif [[ $str[$i] == '\' ]]; then
                ere+="\\\\$str[$i]"
            else
                ere+="$str[$i]"
            fi
        done

        printf -- "%s" "$ere"
    }

    bre2ere() {
        # Basic Regular Expression to Extended Regular Expression
        #
        # What needs to be done:
        # Translate BRE: \+,\{,\},\|,\(,\), +, {, }, |, (, )
        #        to ERE:  +, {, }, |, (, ),\+,\{,\},\|,\(,\)
        #
        # But only if the backslash is not escaped with a backslash.

        local bre ere i re
        bre=$1
        ere=""
        esc=off
        specialchars="\+|\||\{|\}|\(|\)"
        for i in {1..$#bre}; do
            if [[ ${bre[$i]} =~ $specialchars ]]; then
                if [[ $esc == on ]]; then
                    ere+="$bre[$i]" # The escape sign is dropped now
                    esc=off
                else
                    ere+="\\\\$bre[$i]"
                fi
            elif [[ $bre[$i] == "\\" ]]; then
                if [[ $esc == on ]]; then
                    ere+="\\\\\\\\"
                    esc=off
                else
                    esc=on
                fi
            else
                ere+="$bre[$i]"
                esc=off
            fi
        done
        printf -- "%s" "$ere"
    }

    swap_command() {
        flag=1
        reply[$i]="awk --"
    }

    # Some debugging/testing convenience functions:

    [[ -n $1 ]] && {
        echo $($1 "$@")
        return $?
    }
    echo now here

    # Store line as $reply[@]:
    split-shell-arguments

    # `flag` keeps the program state while looping through the splitted
    # shell words. Its semantics:
    # flag==0:  No 'grep', egrep', 'fgrep' encountered yet.
    # flag==1:  Set when grep command is replaced by awk
    #           command. Options or regex.
    # flag==2:  Regex (End of options arrived).
    # flag==3:  The rest.
    flag=0
    cursor=0
    for (( i=1; i<=$#reply; i++ )); do
        if (( i%2==1 && flag < 3 )); then
            # Uneven "words" are whitespace. Only interested in changing the
            # cursor position if exchanging the regex is not replaced by the awk
            # program yet (flag < 3).
            len=$#reply[$i]
            (( cursor += len ))
        elif [[ $flag == 0 ]]; then
            case $reply[$i] in
                (grep)
                    swap_command
                    ;|
                (egrep)
                    swap_command
                    typeset "opt[E]"=1
                    ;|
                (fgrep)
                    swap_command
                    typeset "opt[F]"=1
                    ;|
                (*)
                    (( cursor += $#reply[$i] ))
            esac
        elif [[ $flag == 1 && $reply[$i] = -* ]]; then
            # Is it an option to grep? A regular expression of
            # the options that are recognized:
            grepopts="c|E|F|G|H|i|l|L|n|v|w|x|y"
            # Is it the End of Options-marker?
            if [[ $reply[$i] == "--" ]]; then
                flag=2
            else
                for ((l=1; l<$#reply[$i]; l++)); do
                    #check those options!
                    o=${reply[$i]:$l:1}
                    if [[ $o =~ $grepopts ]]; then
                        typeset "opt[$o]"=1
                    elif [[ $o == "-" ]]; then
                        zle -M "grep2awk: Long options to grep are not supported"
                        return 1
                    else
                        zle -M "grep2awk: Option $o is not supported"
                        return 1
                    fi
                done
                [[ $o == "e" ]] && flag=2
            fi

            # Delete the options, and the now superfluous whitespace:
            reply[$i]=""
            reply[$i+1]=""
            # And leave the cursor pointer where it was.

        elif (( flag==1 || flag==2 )); then
            # The fall-through for opt_or_reg OR regex:
            # This is the regex.
            reply[$i]=$(regex2awkprog $reply[$i])
            (( cursor += $#reply[$i] - 2 ))
            flag=3
        fi
        # Append the current version of $reply[$i] to replacement_line:
        replacement_line+=$reply[$i]
    done

    # Now we are done. Apply the changes to the BUFFER:
    BUFFER="$replacement_line"
    CURSOR=cursor
}

main "$@"


# vim: ft=zsh
